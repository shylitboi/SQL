# 📌 1. 가격이 제일 비싼 식품 정보 조회

## 문제 설명

다음은 식품의 정보를 담고 있는 `FOOD_PRODUCT` 테이블입니다.

### FOOD_PRODUCT 테이블

| 컬럼명        | 설명               |
|-------------|------------------|
| PRODUCT_ID  | 식품 ID (기본 키)     |
| PRODUCT_NAME| 식품 이름            |
| PRODUCT_CD  | 식품 코드            |
| CATEGORY    | 식품 분류            |
| PRICE       | 식품 가격            |

---

## 문제 조건

* 가격(PRICE)이 **가장 비싼 식품**을 조회
* 출력 컬럼: `PRODUCT_ID`, `PRODUCT_NAME`, `PRODUCT_CD`, `CATEGORY`, `PRICE`

---

## 풀이 과정

### 1. 집계 함수 `MAX()` 사용

* `MAX(PRICE)`는 전체 식품 중 가장 높은 가격을 반환
* 단일 값을 반환하므로 직접 비교는 불가능
* **서브쿼리**로 먼저 `MAX(PRICE)`를 구한 뒤, 해당 가격과 같은 행을 메인 쿼리에서 필터링

```sql
SELECT MAX(PRICE)
FROM FOOD_PRODUCT
````

---

### 2. 서브쿼리 사용 이유

* `WHERE` 절에서 집계 함수는 직접 사용할 수 없음
* 예: `WHERE PRICE = MAX(PRICE)` → ❌ 문법 오류
* 따라서, 서브쿼리로 `MAX(PRICE)` 값을 먼저 구하고,
  메인 쿼리에서 그 결과를 조건으로 사용해야 함

---

### 3. 최종 조회 조건

* `PRICE = (SELECT MAX(PRICE) FROM FOOD_PRODUCT)`
* 가장 비싼 가격을 가진 행만 필터링
* 출력 컬럼은 전체 정보

---

## 최종 SQL 쿼리

```sql
SELECT PRODUCT_ID, PRODUCT_NAME, PRODUCT_CD, CATEGORY, PRICE
FROM FOOD_PRODUCT
WHERE PRICE = (
    SELECT MAX(PRICE)
    FROM FOOD_PRODUCT
);
```

---

## 🔍 서브쿼리 정리

### ▶ 서브쿼리란?

> SQL문 안에 포함된 또 하나의 쿼리로, 먼저 실행되어 메인 쿼리에서 그 결과를 사용하는 방식

### ▶ 위치별 예시

| 위치        | 설명                            |
| --------- | ----------------------------- |
| `SELECT`절 | 열 값을 계산하여 출력할 때 사용            |
| `FROM`절   | 인라인 뷰(가상 테이블)로 사용             |
| `WHERE`절  | 조건 비교 시 사용 (`=`, `IN`, `>`) 등 |

---

## ⚡ 간단 버전 (정렬 + LIMIT)

```sql
SELECT PRODUCT_ID, PRODUCT_NAME, PRODUCT_CD, CATEGORY, PRICE
FROM FOOD_PRODUCT
ORDER BY PRICE DESC
LIMIT 1;
```


# 📌 2. 보호소에 들어온 동물 이름 수 구하기

## 문제 설명

`ANIMAL_INS` 테이블은 동물 보호소에 들어온 동물의 정보를 담고 있습니다.

### ANIMAL_INS 테이블 구조

| 컬럼명             | 설명                             |
|------------------|--------------------------------|
| ANIMAL_ID        | 동물 ID (기본 키)                    |
| ANIMAL_TYPE      | 생물 종                           |
| DATETIME         | 보호 시작일                         |
| INTAKE_CONDITION | 보호 시작 시 상태                    |
| NAME             | 동물 이름 (중복 허용, `NULL` 가능)    |
| SEX_UPON_INTAKE  | 성별 및 중성화 여부                   |

---

## 문제 조건

* `NAME` 컬럼에서 **중복을 제거한 이름의 개수**를 구해야 함
* 단, **이름이 없는 경우(`NULL`)는 제외**
* 출력 컬럼명은 자유

---

## 예시 데이터

| ANIMAL_ID | ANIMAL_TYPE | DATETIME            | INTAKE_CONDITION | NAME      | SEX_UPON_INTAKE |
|-----------|-------------|---------------------|------------------|-----------|-----------------|
| A562649   | Dog         | 2014-03-20 18:06:00 | Sick             | NULL      | Spayed Female   |
| A412626   | Dog         | 2016-03-13 11:17:00 | Normal           | *Sam      | Neutered Male   |
| A563492   | Dog         | 2014-10-24 14:45:00 | Normal           | *Sam      | Neutered Male   |
| A513956   | Dog         | 2017-06-14 11:54:00 | Normal           | *Sweetie  | Spayed Female   |

→ 이름이 `NULL`, `*Sam`, `*Sam`, `*Sweetie`인 경우  
→ 유효하고 고유한 이름은 `*Sam`, `*Sweetie` → **총 2개**

---

## 풀이 과정

### 1. `NULL` 제외 조건

```sql
WHERE NAME IS NOT NULL
````

→ 이름이 없는 경우를 제외해야 집계 정확

---

### 2. 고유한 이름만 카운트

```sql
SELECT COUNT(DISTINCT NAME)
```

→ `DISTINCT`는 **중복 제거** 기능을 수행
→ `*Sam`이 두 번 있어도 1번만 계산됨

---

## 최종 SQL 쿼리

```sql
SELECT COUNT(DISTINCT NAME) AS count
FROM ANIMAL_INS
WHERE NAME IS NOT NULL;
```

# 📌 3. 물고기 종류별 가장 큰 물고기 조회(lv.3)

## 문제 설명

`FISH_INFO` 테이블과 `FISH_NAME_INFO` 테이블이 주어졌습니다.

### 1. FISH_INFO 테이블 (잡은 물고기 정보)

| 컬럼명   | 설명                      |
|--------|-------------------------|
| ID     | 물고기 고유 번호              |
| FISH_TYPE | 물고기 종류 (숫자)         |
| LENGTH | 물고기 길이 (cm, 10cm 이하는 NULL) |
| TIME   | 잡은 날짜                   |

※ `LENGTH`가 NULL인 경우는 모두 **10cm 이하**이며,  
**NULL만 존재하는 경우는 없음**

---

### 2. FISH_NAME_INFO 테이블 (물고기 이름 정보)

| 컬럼명     | 설명              |
|----------|-----------------|
| FISH_TYPE | 물고기 종류 (숫자) |
| FISH_NAME | 물고기 이름 (문자) |

---

## 문제 조건

- 각 물고기 종류(`FISH_TYPE`)별로
  - 가장 큰 물고기 1마리의 정보를 조회
- 출력 컬럼:  
  `ID`, `FISH_NAME`, `LENGTH`
- `ID` 기준 오름차순 정렬
- **가장 큰 물고기는 종류별로 1마리만 존재함**
- **10cm 이하(NULL)** 물고기가 최대가 되는 경우는 없음

---

## 잘못된 풀이 🎱

```sql
SELECT I.ID, N.FISH_NAME, I.LENGTH
FROM FISH_INFO AS I 
JOIN FISH_NAME_INFO AS N 
  ON I.FISH_TYPE = N.FISH_TYPE
GROUP BY I.FISH_TYPE
HAVING LENGTH = (SELECT MAX(LENGTH) FROM FISH_INFO)
ORDER BY I.ID ASC;
````

>###  틀린 이유

| 문제점                                                   | 설명                                                                                             |
| ----------------------------------------------------- | ---------------------------------------------------------------------------------------------- |
| `GROUP BY I.FISH_TYPE` 사용                             | `SELECT` 절에 있는 `I.ID`, `N.FISH_NAME`, `I.LENGTH`는 **집계함수가 아니고**, **GROUP BY에도 없음** → 오류 발생 가능성 |
| `HAVING LENGTH = (SELECT MAX(LENGTH) FROM FISH_INFO)` | **전체 물고기 중 가장 큰 길이 하나**만 비교 → **종류별 최대값 비교 아님**                                                |

---

## ✅ 풀이 과정

### 1. 물고기 종류별 최대 길이 구하기

```sql
SELECT FISH_TYPE, MAX(LENGTH)
FROM FISH_INFO
GROUP BY FISH_TYPE
```

→ 각 종류별로 가장 큰 물고기의 `LENGTH`를 구함

---

### 2. 해당 길이와 종류가 같은 행만 추출

```sql
WHERE (I.FISH_TYPE, I.LENGTH) IN (
  SELECT FISH_TYPE, MAX(LENGTH)
  FROM FISH_INFO
  GROUP BY FISH_TYPE
)
```

→ `FISH_TYPE`과 `LENGTH`가 둘 다 일치하는 물고기만 필터링
→ \*\*조건을 튜플(FISH\_TYPE, LENGTH)\*\*로 비교함

---

### 3. 이름 붙이기 (`JOIN`)

```sql
JOIN FISH_NAME_INFO AS N
ON I.FISH_TYPE = N.FISH_TYPE
```

→ 물고기 종류 번호에 해당하는 이름을 붙임

---

### 4. 정렬

```sql
ORDER BY I.ID ASC
```

---

## ✅ 최종 SQL 쿼리

```sql
SELECT I.ID, N.FISH_NAME, I.LENGTH
FROM FISH_INFO AS I
JOIN FISH_NAME_INFO AS N
  ON I.FISH_TYPE = N.FISH_TYPE
WHERE (I.FISH_TYPE, I.LENGTH) IN (
    SELECT FISH_TYPE, MAX(LENGTH)
    FROM FISH_INFO
    GROUP BY FISH_TYPE
)
ORDER BY I.ID ASC;
```

---

## 🔍 포인트 요약

| 포인트                                 | 설명                                                       |
| ----------------------------------- | -------------------------------------------------------- |
| `GROUP BY` 사용 시                     | `SELECT`에 있는 컬럼은 모두 **GROUP BY에 포함**하거나 **집계 함수**로 감싸야 함 |
| `MAX(LENGTH)`                       | **종류별로** 최댓값을 구해야 하므로, 반드시 `GROUP BY`와 함께 사용해야 함         |
| `WHERE (A, B) IN (SELECT A, B ...)` | 튜플 형태 조건 비교로 **두 컬럼 동시에 일치**하는 행만 선택 가능                  |


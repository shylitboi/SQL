# 📌 1. 상품코드 별 오프라인 매출액 합계 조회

## 문제 설명

다음은 의류 쇼핑몰의 상품 정보와 오프라인 판매 정보를 담고 있는 두 개의 테이블입니다.

### PRODUCT 테이블

| 컬럼명        | 설명              |
|--------------|-----------------|
| PRODUCT_ID   | 상품 ID (기본 키)   |
| PRODUCT_CODE | 8자리 상품 코드 (앞 2자리는 카테고리 코드) |
| PRICE        | 판매가 (정가)       |

### OFFLINE_SALE 테이블

| 컬럼명           | 설명                        |
|-----------------|---------------------------|
| OFFLINE_SALE_ID | 오프라인 판매 ID (기본 키)     |
| PRODUCT_ID      | 판매된 상품 ID                |
| SALES_AMOUNT    | 판매 수량                    |
| SALES_DATE      | 판매 일자                    |

---

## 문제 조건

- 상품코드(PRODUCT_CODE) 별 **총 매출액(PRICE × SALES_AMOUNT)**을 구함
- 출력 컬럼: `PRODUCT_CODE`, `SALES`
- 결과 정렬:  
  1. `SALES` 내림차순  
  2. 같은 매출일 경우 `PRODUCT_CODE` 오름차순

---

## 풀이 과정

### 1. 매출액 계산

* `PRODUCT` 테이블에서 `PRICE`  
* `OFFLINE_SALE` 테이블에서 `SALES_AMOUNT`  
* 이 두 값을 곱한 결과가 **매출액**

```sql
PRICE * SALES_AMOUNT AS SALES
````

---

### 2. 두 테이블 JOIN

* 판매 이력에는 `PRODUCT_ID`만 있으므로 상품 정보를 위해 조인 필요

```sql
FROM OFFLINE_SALE OS
JOIN PRODUCT P ON OS.PRODUCT_ID = P.PRODUCT_ID
```

---

### 3. 상품코드 별 그룹화 및 합산

```sql
GROUP BY P.PRODUCT_CODE
```

---

### 4. 정렬 조건

```sql
ORDER BY SALES DESC, PRODUCT_CODE ASC
```

---

## 최종 SQL 쿼리

```sql
SELECT P.PRODUCT_CODE, SUM(P.PRICE * OS.SALES_AMOUNT) AS SALES
FROM OFFLINE_SALE OS
JOIN PRODUCT P ON OS.PRODUCT_ID = P.PRODUCT_ID
GROUP BY P.PRODUCT_CODE
ORDER BY SALES DESC, P.PRODUCT_CODE ASC;
```

---

## 🔍 핵심 정리

| 요소                     | 설명                                                |
| ---------------------- | ------------------------------------------------- |
| `JOIN`                 | 상품 가격을 가져오기 위해 `PRODUCT` 테이블과 `OFFLINE_SALE`을 조인함 |
| `PRICE * SALES_AMOUNT` | 개별 판매 건의 매출 계산                                    |
| `SUM(...)`             | 같은 상품코드의 모든 판매 건 매출을 합산함                          |
| `GROUP BY`             | 상품코드별로 묶기                                         |
| `ORDER BY`             | 매출액 내림차순, 동일 매출일 경우 상품코드 오름차순 정렬                  |



# 📌 2. 있었는데요 없었습니다

## 문제 설명

`ANIMAL_INS`와 `ANIMAL_OUTS` 두 테이블이 존재합니다.

### ANIMAL_INS 테이블

| 컬럼명             | 설명                     |
|------------------|------------------------|
| ANIMAL_ID        | 동물 ID (기본 키)          |
| ANIMAL_TYPE      | 동물 종류 (`Cat`, `Dog` 등) |
| DATETIME         | 보호 시작일               |
| INTAKE_CONDITION | 입소 당시 건강 상태         |
| NAME             | 이름 (nullable)         |
| SEX_UPON_INTAKE  | 입소 시 성별 및 중성화 여부    |

---

### ANIMAL_OUTS 테이블

| 컬럼명              | 설명                      |
|-------------------|-------------------------|
| ANIMAL_ID         | 동물 ID (외래 키)           |
| ANIMAL_TYPE       | 동물 종류                  |
| DATETIME          | 입양일                    |
| NAME              | 이름 (nullable)           |
| SEX_UPON_OUTCOME  | 입양 시 성별 및 중성화 여부   |

---

## 문제 조건

- **입양일이 보호 시작일보다 빠른 경우만** 조회
- 출력 컬럼: `ANIMAL_ID`, `NAME`
- 정렬 조건: 보호 시작일(`ANIMAL_INS.DATETIME`) **오름차순**

---

## 예시

| ANIMAL_ID | 보호시작일             | 입양일                |
|-----------|----------------------|----------------------|
| A381217   | 2017-07-08 09:41:00  | 2017-06-09 18:51:00  |

→ 보호 시작일보다 입양일이 **더 빠르므로 잘못된 데이터** → 출력 대상

---

## 풀이 과정

### 1. 보호 시작일과 입양일 비교

```sql
WHERE OUTS.DATETIME < INS.DATETIME
````

→ 입양일이 보호 시작일보다 이른 데이터만 필터링

---

### 2. 두 테이블 JOIN

* `ANIMAL_ID`가 기본 키이자 외래 키 → 내부 조인 사용

```sql
FROM ANIMAL_INS INS
JOIN ANIMAL_OUTS OUTS ON INS.ANIMAL_ID = OUTS.ANIMAL_ID
```

---

### 3. 출력 컬럼

* 문제에서 요구한 컬럼: `ANIMAL_ID`, `NAME`

※ 둘 다 `INS.NAME`과 `OUTS.NAME`이 존재하지만, 일반적으로 같은 값이므로 아무 쪽이나 사용 가능

---

### 4. 정렬 조건

```sql
ORDER BY INS.DATETIME ASC
```

---

## 최종 SQL 쿼리

```sql
SELECT INS.ANIMAL_ID, INS.NAME
FROM ANIMAL_INS AS INS
JOIN ANIMAL_OUTS AS OUTS
  ON INS.ANIMAL_ID = OUTS.ANIMAL_ID
WHERE OUTS.DATETIME < INS.DATETIME
ORDER BY INS.DATETIME;
```

---

## 🔍 핵심 요약

| 요소                               | 설명                          |
| -------------------------------- | --------------------------- |
| `JOIN`                           | 입양일과 보호일 비교를 위해 두 테이블 연결 필요 |
| `OUTS.DATETIME < INS.DATETIME`   | 입양일이 보호 시작일보다 빠른 경우만 필터링    |
| `ORDER BY INS.DATETIME`          | 보호 시작일 기준 오름차순 정렬           |
| `SELECT INS.ANIMAL_ID, INS.NAME` | 요구된 컬럼만 출력                  |


# 📌 3. 특정 기간동안 대여 가능한 자동차들의 대여비용 구하기

## 문제 설명

다음 3개의 테이블이 주어진다:

### 1. `CAR_RENTAL_COMPANY_CAR` (차량 정보)

| 컬럼명     | 설명                          |
|------------|-------------------------------|
| CAR_ID     | 자동차 ID                     |
| CAR_TYPE   | 자동차 종류 (`세단`, `SUV` 등)    |
| DAILY_FEE  | 일일 대여 요금 (정수)             |
| OPTIONS    | 옵션 리스트 (콤마로 구분된 문자열) |

---

### 2. `CAR_RENTAL_COMPANY_RENTAL_HISTORY` (대여 이력)

| 컬럼명      | 설명                  |
|-------------|-----------------------|
| HISTORY_ID  | 대여 이력 ID           |
| CAR_ID      | 자동차 ID              |
| START_DATE  | 대여 시작일             |
| END_DATE    | 대여 종료일             |

---

### 3. `CAR_RENTAL_COMPANY_DISCOUNT_PLAN` (할인 정책)

| 컬럼명         | 설명                              |
|----------------|-----------------------------------|
| PLAN_ID        | 할인 정책 ID                       |
| CAR_TYPE       | 자동차 종류                         |
| DURATION_TYPE  | 대여 기간 조건 ('7일 이상', '30일 이상' 등) |
| DISCOUNT_RATE  | 할인율 (%)                         |

---

## 문제 조건 요약

- 자동차 종류: `'세단'`, `'SUV'`
- **대여 가능 기간**: `2022-11-01 ~ 2022-11-30` 동안 **대여 이력이 없는 차**
- 대여 기간: **30일**
- 적용 할인: `30일 이상` 할인 정책
- 최종 대여 금액(`FEE`) 계산:  
  `FEE = DAILY_FEE × 30 × (1 - 할인율 / 100)`
- 조건 만족:  
  `FEE >= 500000 AND FEE < 2000000`
- 출력 컬럼: `CAR_ID`, `CAR_TYPE`, `FEE`
- 정렬 조건:  
  1. `FEE` 내림차순  
  2. `CAR_TYPE` 오름차순  
  3. `CAR_ID` 내림차순

---

## 최종 SQL 쿼리

```sql
SELECT
    C.CAR_ID,
    C.CAR_TYPE,
    FLOOR(C.DAILY_FEE * 30 * (1 - D.DISCOUNT_RATE / 100)) AS FEE
FROM CAR_RENTAL_COMPANY_CAR C
JOIN CAR_RENTAL_COMPANY_DISCOUNT_PLAN D
  ON C.CAR_TYPE = D.CAR_TYPE
WHERE D.DURATION_TYPE = '30일 이상'
  AND C.CAR_TYPE IN ('세단', 'SUV')
  AND C.CAR_ID NOT IN (
      SELECT CAR_ID
      FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY
      WHERE START_DATE <= '2022-11-30' AND END_DATE >= '2022-11-01'
  )
  AND FLOOR(C.DAILY_FEE * 30 * (1 - D.DISCOUNT_RATE / 100)) >= 500000
  AND FLOOR(C.DAILY_FEE * 30 * (1 - D.DISCOUNT_RATE / 100)) < 2000000
ORDER BY FEE DESC, C.CAR_TYPE ASC, C.CAR_ID DESC;
````

---

## 🔍 풀이 과정

### 1. 할인율 적용을 위한 `JOIN`

```sql
JOIN CAR_RENTAL_COMPANY_DISCOUNT_PLAN D
  ON C.CAR_TYPE = D.CAR_TYPE
WHERE D.DURATION_TYPE = '30일 이상'
```

→ 자동차 종류별 `30일 이상` 할인율 적용

---

### 2. 11월 대여 가능 차량 필터링

```sql
C.CAR_ID NOT IN (
    SELECT CAR_ID
    FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY
    WHERE START_DATE <= '2022-11-30' AND END_DATE >= '2022-11-01'
)
```

→ **11월 1일\~30일** 동안 **겹치는 대여 기록이 있는 차량은 제외**

---

### 3. 대여 요금 계산

```sql
FLOOR(C.DAILY_FEE * 30 * (1 - D.DISCOUNT_RATE / 100))
```

→ 할인율 적용 후 30일간의 금액을 **정수로 내림 처리**

---

### 4. 대여 금액 범위 필터링

```sql
... >= 500000 AND ... < 2000000
```

→ 조건에 맞는 차량만 필터

---

### 5. 정렬 조건

```sql
ORDER BY FEE DESC, C.CAR_TYPE ASC, C.CAR_ID DESC
```

---

## ✅ 핵심 정리

| 항목          | 설명                                        |
| ----------- | ----------------------------------------- |
| 할인율 적용 조건   | `JOIN + DURATION_TYPE = '30일 이상'`         |
| 대여 가능 여부 판단 | **NOT IN** 서브쿼리로 **11월 내 겹치는 기록 제외**      |
| 대여 금액 계산    | `FLOOR(DAILY_FEE * 30 * (1 - 할인율 / 100))` |
| 다중 정렬       | `FEE DESC`, `CAR_TYPE ASC`, `CAR_ID DESC` |


# 1.과일로 만든 아이스크림 고르기

## 문제 설명

두 개의 테이블이 있습니다:

### 1. FIRST_HALF 테이블 (상반기 주문 정보)

| 컬럼명          | 설명             |
| ------------ | -------------- |
| SHIPMENT\_ID | 출하 번호          |
| FLAVOR       | 아이스크림 맛 (기본 키) |
| TOTAL\_ORDER | 상반기 총 주문량      |

---

### 2. ICECREAM_INFO 테이블 (성분 정보)

| 컬럼명              | 설명                                      |
| ---------------- | --------------------------------------- |
| FLAVOR           | 아이스크림 맛 (기본 키)                          |
| INGREDIENT\_TYPE | 주성분 종류 (`sugar_based` 또는 `fruit_based`) |

---

## 📌 문제 조건

* 주문량(TOTAL\_ORDER)이 **3000 초과**
* 성분(INGREDIENT\_TYPE)이 **fruit\_based**
* **FLAVOR**만 출력
* **주문량이 많은 순서로 정렬**

---

## 풀이 과정

### 1. JOIN

* 이유: 하나는 주문량, 하나는 성분 정보만 가지고 있기 때문
* 공통 열 `FLAVOR`를 기준으로 테이블을 합쳐야 함

```sql
FROM FIRST_HALF
JOIN ICECREAM_INFO ON FIRST_HALF.FLAVOR = ICECREAM_INFO.FLAVOR
```

---

### 2. 조건 필터링

* 주문량이 3000보다 큰 것
* 성분이 fruit_based인 것

```sql
WHERE FIRST_HALF.TOTAL_ORDER > 3000
  AND ICECREAM_INFO.INGREDIENT_TYPE = 'fruit_based'
```

---

### 3. 필요한 열만 조회

* FLAVOR 열만 조회

```sql
SELECT FIRST_HALF.FLAVOR
```

---

### 4. 주문량 내림차순 정렬

```sql
ORDER BY FIRST_HALF.TOTAL_ORDER DESC
```

---

## 최종 SQL 쿼리

```sql
SELECT FIRST_HALF.FLAVOR
FROM FIRST_HALF
JOIN ICECREAM_INFO ON FIRST_HALF.FLAVOR = ICECREAM_INFO.FLAVOR
WHERE FIRST_HALF.TOTAL_ORDER > 3000
  AND ICECREAM_INFO.INGREDIENT_TYPE = 'fruit_based'
ORDER BY FIRST_HALF.TOTAL_ORDER DESC;
```

---

## 🔍 JOIN 구문 정리

### ▶ 기본 문법

```sql
FROM 테이블1
JOIN 테이블2 ON 테이블1.공통열 = 테이블2.공통열
```

### ▶ 해석

> 테이블1과 테이블2를 공통열이 같은 행들끼리 한 줄로 붙여서 합쳐라

### ▶ 자주 쓰는 JOIN 종류

| JOIN 종류      | 설명                                |
| ------------ | --------------------------------- |
| `INNER JOIN` | 양쪽 테이블에 공통된 값이 있을 때만 합침 (기본 JOIN) |
| `LEFT JOIN`  | 왼쪽 테이블은 모두 가져오고, 오른쪽은 공통된 값만      |
| `RIGHT JOIN` | 오른쪽 테이블은 모두 가져오고, 왼쪽은 공통된 값만      |

---

# 2. 부모의 형질을 모두 가지는 대장균 찾기 


## 문제 설명

### ECOLI_DATA 테이블 (대장균 개체 정보)

| 컬럼명                   | 설명                      |
| --------------------- | ----------------------- |
| ID                    | 대장균 개체 고유 ID (기본 키)     |
| PARENT\_ID            | 부모 개체 ID (최초 개체는 NULL)  |
| SIZE\_OF\_COLONY      | 대장균 개체 크기               |
| DIFFERENTIATION\_DATE | 분화 날짜                   |
| GENOTYPE              | 형질 정보 (정수값, 2진수 비트로 표현) |

---

## 문제 조건

* 부모가 있는 개체만 대상으로 한다 (`PARENT_ID IS NOT NULL`)
* 자식 개체의 형질(GENOTYPE)이 부모의 형질을 모두 포함해야 한다

  * 즉 `자식 & 부모 = 부모` 조건을 만족해야 함
* `ID`, `GENOTYPE`, `PARENT_GENOTYPE`을 출력
* `ID` 기준으로 오름차순 정렬

---

## 풀이 과정

### 1. 자기 자신을 두 번 참조

* 이유: 한 개체의 형질과 부모 개체의 형질을 비교해야 하므로
* 동일 테이블 `ECOLI_DATA`를 두 번 참조해서 각각 자식(A), 부모(B)로 사용
* `A.PARENT_ID = B.ID` 조건으로 부모–자식 관계를 연결

```sql
FROM ECOLI_DATA A, ECOLI_DATA B
WHERE A.PARENT_ID = B.ID
```

---

### 2. 형질 포함 조건 

* 자식이 부모의 형질을 모두 보유한 경우:

  * `(A.GENOTYPE & B.GENOTYPE) = B.GENOTYPE`

```sql
AND A.GENOTYPE & B.GENOTYPE = B.GENOTYPE
```

---

### 3. 필요한 열만 조회

* 자식 ID, 자식 형질, 부모 형질을 출력

```sql
SELECT A.ID, A.GENOTYPE, B.GENOTYPE AS PARENT_GENOTYPE
```

---

### 4. ID 기준 오름차순 정렬

```sql
ORDER BY A.ID
```

---

## 최종 SQL 쿼리

```sql
SELECT A.ID, A.GENOTYPE, B.GENOTYPE AS PARENT_GENOTYPE
FROM ECOLI_DATA A, ECOLI_DATA B
WHERE A.PARENT_ID = B.ID
  AND A.GENOTYPE & B.GENOTYPE = B.GENOTYPE
ORDER BY A.ID;
```

---


# 모의 고사 1회

### 4. 사원엔터티의 주소는  어떤 속성?
* 단순/복합 속성 : 속성값을 세부 의미로 쪼갤 수 있는지 여부
    * 주소는 여러 세부 속성으로 쪼갤 수 있으므로 복합 속성에 해당
* 설계 속성은 원ㄹ ㅐ업무에 존재하지 않지만 설계하면서 도출된 속성(eg : 상품 번호)

### 5. 반정규화
반정규화를 하면 데이터 입력 속도는 오히려 저하될 수 있으며 일번적으로 조회 속도가 향상된다.
### 7. 식별자
* 대체여부에 따른 분류 : 본질 식별자/인조 식별자(주식별자의 속성이 두개 이상인 경우 그 속성들을 하나로 묶어서 사용하는 식별자, 대리식별자라고도 함)


### 12. NULL 관련 함수
* NVL() = IFNULL() : 인수1이 null일 경우 인수 2 반환, 아니면 인수 1 반환
* NULLIF(인수1, 인수2) : 인수1 = 인수2라면 null, 같지 않다면 인수 1반환
```NULLIF(NULL, A)``` -> null


### 17.
테이블이 10,null, 20(한개 칼럼)으로 구성

* where 1 = 2라는 조건절이 있다면 FALSE이므로 반환하지 않음 -> **집계함수에 따라 도출되는게 다름**
    * 그렇다면 select절에 sum, avg, max 등이 온다면 null
    * count(col1)이라면 0
* 죽 select절에 nvl(sum(col1),0)이 있다면 0을 출력하겠지


### 20 계층형 쿼리
* PRIOR 자식 = 부모 형태를 사용하면 순방향 전개
📌 예시
-- 순방향 (부모 → 자식)
```sql
SELECT employee_id, manager_id, LEVEL
FROM employees
CONNECT BY PRIOR employee_id = manager_id;


부모(=매니저)의 employee_id → 자식
```
### 35 기본 key PK
* 테이블당 가질 수 있는 기본 키 개수 → 최대 1개 (아예 없을 수도 있음 → 즉 0 또는 1)

* 기본 키에 포함되는 컬럼 수 → 하나 이상(단일 키 또는 복합 키) 가능

### 37
```sql
WHERE COL1 IN (3,NULL)
```
= 
```SQL
WHERE COL1 = 3 OR COL1 = NULL
```
COLL1 = NULL은 항상 FALSE이므로 COL1 =3 만 반환
* null은 비교될 때 is null or is not null로만 비교되어야 한다




### 38 LIKE + ESCAPE 문자
* ESCAPE로 특정 문자를 지정한뒤 %나 _ **앞**에 붙여서 사용한다. 
* 즉 "%" 가 포함된 문자열 찾기 = LIKE '%@%%' ESCAPE '@'





### 41 계층형 쿼리 내장 함수가 아닌 것 = BLEVEL
* 내장 함수
    * LEVEL
    * CONNECT_BY_ISLEAF
    * CONNECT_BY_ISCYCLE
    * SYS_CONNECT_BY_PATH
    * CONNECT_BY_ROOT
    * NOCYCLE

### 44 COUNT()
* COUNT() <- 괄호 안에 상수가 오는 경우나 별이 온다면 모든 행의 수(null포함)
* count(COL) : COL 칼럼에서 Null제외한 행의 수 출력




# 모의고사 2회

### 3번 주식별자의 특징
* 업무에서 사용하는 용어
* 속성값이 존재해야함
* 복합키로 주식별자를 구성할 경우 너무 많은 속성이 포함되지 않도록 한다.

영속적으로 존재하는 인스턴스의 집합 = 엔터티 
### 4번 개념 엔터티
* 유형 - 무형에서 무형에 속함
    * 개념 엔터티 : 물리적 형태는 없고 관리해야할 개념적 정보로 구본, 조직, 보험 상품, 분반 등 개념적으로 존재
    * 사건 엔터티 : 업무를 수행함에 따라 발생되는 엔터티로 데이터양이 많고 통계에 활용

-> 조직, 보험상품 : 유형 없음
-> 주문, 청구미납 -> 사건 엔터티

## 13번 
```sql
SELECT NVL(COUNT(*). 9999)
FRP, ~
WHERE 1 =2
```
-> WHERE 1= 2이므로 항상 false, 아무 행도 반환하지 않음
-> 이를 count 하니까 0을 반환

### 16번 계층형 쿼리
* 계층형 쿼리는 FROM -> START WITH -> CONNECTY BY -> WHERE절 순으로 간다

### 18번 관리구문
* DDL : CREATE, ALTER, RENAME, DROP, TRUNCATE
* DML : INSERT, SELECT, UPDATE, DELETE
* DCL : GRANT, REVOKE
* TCL  : COMMIT, ROLLBACK, SAVEPOINT

### 19번 NATURAL JOIN
: 두 테이블 간 동일 이름을 갖는 모든 컬럼에 대해 EQUI JOIN을 수행함
* 그렇기 떄문에 별도의 ON절이 없음
* USING 절과 함께 사용할 수 없음



---

## 📌 1. `USING` 절의 의미

* `JOIN ... USING(컬럼)` 은 **양쪽 테이블에 같은 이름을 가진 컬럼**이 있을 때만 사용 가능.
* 해당 컬럼을 기준으로 조인하면서, **SELECT 결과에서는 그 컬럼을 1번만 보여줌**.
* 즉, `USING`에 적힌 컬럼은 양쪽 테이블에서 공통으로 쓰이므로 **테이블명(별칭)으로 수식할 수 없음**.

```sql
SELECT employee_id, department_id
FROM employees e
JOIN departments d USING(department_id);
```

* `department_id`는 `employees`와 `departments` 둘 다 가지고 있지만,
  결과에서는 한 번만 출력됨.
* `e.department_id` 또는 `d.department_id` 라고 쓰면 에러남 ❌

---

## 📌 2. `NATURAL JOIN`

* `NATURAL JOIN` 은 **양쪽 테이블에 이름이 같은 모든 컬럼을 자동으로 조인 조건으로 사용**.
* 따라서 `USING`을 **명시할 수 없음** (이미 내부적으로 자동 적용된 개념이라 충돌).

```sql
SELECT employee_id, department_id
FROM employees NATURAL JOIN departments;
```

* 두 테이블에 `department_id`라는 공통 컬럼이 있으면 자동으로 그 컬럼 기준으로 JOIN.
* 결과에서도 `department_id`는 1번만 표시됨.

---

## 📌 3. 비교 요약

| 구분                 | 특징              | SELECT 시 제약               |
| ------------------ | --------------- | ------------------------- |
| **JOIN ... ON**    | 원하는 조건 자유롭게     | 컬럼은 반드시 테이블명/별칭 붙여야 함     |
| **JOIN ... USING** | 공통 컬럼명, 단일 컬럼만 지정 가능   | USING에 적은 컬럼은 테이블명 붙이면 에러 |
| **NATURAL JOIN**   | 공통 컬럼명 전부 자동 매칭 | 공통 컬럼은 1번만 표시, USING 불가   |

---

✅ 따라서

* `USING` → "공통 컬럼 하나를 지정해서 조인"
* `NATURAL JOIN` → "공통 컬럼 전부를 자동으로 조인"
  이고, 둘 다 **SELECT절에서 그 공통 컬럼은 테이블명 못 붙인다** 라고 기억하면 돼요.


# 모의고사 3회

### 6번 발생시점에 따른 엔터티 분류

* 기본 엔터티 : 원래 존재하는 정보, 독립적으로 생성 가능
* 중심 엔터티 : 기본 엔터티로부터 발생, 중심적인 역할, 데이터 양 많음, 많은 행위 엔터티 생성
* 행위 엔터티 : 2개 이상 엔터티로부터 발생, 자주 바뀌고 데이터량 증가

### 21번 ORDER BY
* Select 구문에 사용되지 않은 컬럼도 order by 구문에서 사용할 수 있다
* col1, 2와 같이 컬럼과 숫자를 혼용할 수 있다
* 숫자를 사용할 경우 select절에 사용된 컬럼 숫자 개수 초과하면 안된다

### 33번 어제 날짜 조회
* SYSDATE 함수는 현재의 날짜 데이터를 반환 여기에 1을 빼면 어제 날짜 반환하게 된다
* 이따 YYYYMMDD라는 포맷에 맞게 데이터를 출력하기 위해선 TO_CAHR함수로 형변환이 필요하다. 
* 그냥 원하는 형식으로 출력하려면 형변환 해야함

### 37번 문자열 함수
* LPAD(문자열, 총길이, 채울 문자)
* LTRIM('XYZXYZ', 'XYZ') : 가장 왼쪽의 문자가 XYZ중 하낭리 때 해당 문자를 지운 후 데이터 반환. for문처럼 계속 반복함

### 50번 누적 백분율 구하는 함수
* CUME_DIST 
* RATIO_TO_REPORT: 누적이 아니라 파티션별 합계에서 차지하는 비율을 구하는 함수


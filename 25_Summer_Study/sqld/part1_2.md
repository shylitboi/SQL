# Chapter 2 데이터 모델과 SQL

>## 정규화
```
데이터 정합성을 위해 엔터티를 작은 단위로 분리하는 과정
```
* 중복성 제거, 정규화 할수록 엔터티는 증가, 데이터의 입력, 수정, 삭제 성능 향상
* 데이터 조회 성능은 JOIN으로 인해 성능 저하 발생 가능

### 종속이란
정규화 이론에서 종속(Dependency)은 보통 **함수 종속(Functional Dependency)**을 의미합니다.

속성 B가 속성 A에 종속된다
→ A의 값이 정해지면 B의 값이 항상 유일하게 결정된다.
* A: 결정자(Determinant)
* B: 종속자(Dependent)

의미: 같은 A값을 가진 두 튜플은 항상 같은 B값을 가짐.
### 조건
1. 제 1정규형 : 모든 속성은 하나의 값만 가진다, 유사한 속성(attribute)이 반복되는 경우에도 1차 정규화의 대상이 된다
    * why? 데이터를 꺼내 쓸 때 귀찮게 split해서 써야함, 유사한 속성이 반복되는 경우 데이터가 늘어날 대 마다 계속해서 속성을 추가해야함, 또한 모든 인스턴스가 추가된 속성의 개수만큼 속성값을 가지고 있지 않을 수 있으므로 공간의 낭비 발생 여지 o(null값이 생김)
2. 제 2정규형 : ```엔터티의 모든 일반속성은 반드시 모든 주식별자에 종속```
    * 주식별자가 단일 식별자가 아닌 복합식별자인 경우 주식별자에 일부에만 종속될 수 있음
    * eg) 주식별자 : 주문번호, 음료코드, 일반속성인 음료명은 음료코드에 종속됨
        * 이때 주문이 되지 않는 음료는 입력을 할 수 없으며 음료명이 변경될경우 주문 데이터가 모두 변경되어야하는 문제 발생함
3. 제 3정규형 : 주식별자가 아닌 모든 속성 간에는 서로 종속될 수 없음
4. 주의사항 : 지나친 정규화는 성능저하를 일으킨다
    * 굳이 여러번 join을 해야 하는 경우

>## 반정규화
* 정의 : 조회 성능을 향상시키기 위해 데이터 중복을 허용하거나 데이터를 그룹핑하는 과정
    * 조회 성능은 향상될 수 있으나, 입력, 수정, 삭제 성능은 저하 가능성
    * 데이터 정합성 이슈 발생 가능
    * 반정규화는 정규화가 끝난후 거치게 된다

### 테이블 반정규화

* 테이블 병합 : 업무 프로세스상 JOIN이 필요한 경우가 많아 테이블을 통합하는 것이 성능 측면에서 유리한 경우 고려
    1) 1:1 관계 테이블 병합
    2) 1:m 관계 테이블 병합 
        * 중복된 데이터가 생길 수 있음
        * 1쪽에 해당하는 엔터티의 속성 개수가 많으면 중복데이터가 많아지므로 테이블 병합에 적절치 못함
* **테이블 분할**
    1) 테이블 수직 분할 : 엔터티의 일부 속성을 별도의 엔터티로 분할
        * 테이블 수직 분할하면 1:! 관계의 테이블이 두개가 생긴다
        * 자주 사용하는 속성이 아니거나, 대부분 인스턴스가 null로 갖고 있을때 고려
        * 수직 분할 하면 한개의 블록에 더 많은 인스턴스 저장 가능
        ```
        📌 
        1. 블록이란? : 데이터베이스에서 데이터를 읽고 쓰는 가장 작은 단위의 저장 공간

        디스크나 메모리에 저장되는 **고정 크기(chunk)**의 데이터 묶음

        크기는 보통 4KB, 8KB, 16KB 등 DB 설정에 따라 정해짐
        (예: 오라클 기본 8KB, MySQL/InnoDB는 기본 16KB)

        2. 왜 블록이 중요한가?
        DB는 레코드를 하나씩 디스크에서 읽는 게 아니라 블록 단위로 읽음

        블록 하나에 여러 행(레코드)이 들어감

       *  즉 수직 분할 하면 고정된 저장 공간에 열 수가 줄어들어 더 많은 행(인스턴스) 저장 가능해짐
       ```
    2) 테이블 수평 분할 : 인스턴스를 기준으로 별도의 엔터티로 분할(파티셔닝)
        * 관계가 없는 다수의 테이블이 생성된다
        * 주로 **기간** 을 기준으로 분할하긴 함
    3) 테이블 추가
        * 중복 테이블 추가 : 성능상 반드시 필요하다고 판단되는 경우
        * 통계 테이블 추가 : 통계치를 미리 계산하여 저장 느낌
        * 이력 테이블 추가
        * 부분 테이블 추가 : ```eg) 회원 대상 메일 발송건이 다량으로 생기는 경우 메일 발송에 필요한 정보만 부분 테이블로 생성```

* **컬럼 반정규화**
    1) 중복 컬럼 추가 : 조인할 경우가 많아 성능 측면에서 유리한 경우
    2) 파생 컬럼 추가 : 계산 미리 칼럼으로 추가하는 느낌
    3) 이력 테이블 컬럼 추가 : 대량의 이력 테이블을 조회할때 등

* **관계 반정규화(중복 관계 추가)** : 업무 프로세스상 조인할 경우가 많아 중복 관계를 추가하는 것이 성능 측면에서 유리할 때 

>## 트랜잭션

* 정의 
    * 데이터베이스에서 하나의 작업 단위(Unit of Work)
        * 논리적인 작업 단위, 물리적인 작업단위 X
        * COMMIT 으로 묶인다

    *  여러 SQL 명령(INSERT, UPDATE, DELETE 등)을 묶어서 모두 성공하거나, 모두 실패하게 만드는 메커니즘

    * “중간 상태” 없이 완전한 성공 또는 완전한 실패만 허용
* 특징
    1) 원자성 : 트랜잭션은 분리가 불가능한 업무의 최소 단위로 전부 처리되거나 하나도 처리되지 않아야함
    2) 일관성 : 하나의 트랜잭션이 완료된후 db는 여전히 일관된 상태여야함
    3) 고립성 : 실행중인 트랜잭션의 중간 결과에 다른 트랜잭션이 접근 불가
    4) 지속성 : 트랜잭션이 실행 완료되면 결과는 db에 영속적으로 저장됨

* 예시
```
A가 B에게 1만 원 송금한다고 할 때:

A 계좌에서 1만 원 차감

B 계좌에 1만 원 추가

이 두 과정이 둘 다 성공해야 송금 성공.
중간에 오류가 나면 둘 다 취소(ROLLBACK)해서 데이터 불일치 방지.
```

>## NULL
* null? : 존재하지 않음. 즉 값이 없음, 0과는 다른 의미
* SQL에서 null 처리 방식
    1) 가로 연산 : null이 포함되어있는 속성값 select시 결과값은 null
    2) 세로 연산 : ```다른 인스턴스의 데이터와 연산할 때는 null값을 제외한다```

>## 본질 식별자 vs 인조 식별자

* 본질 : 업무 프로세스 상 존재하며 가공되지 않고, 원조 식별자라고도함
* 인조 : 주식별자의 속성이 두개 이상인 경우 그 속성들을 하나로 묶어서 사용
    * 주로 복합식별자인 경우 간결한 식별자로 대체하기 위해 인조식별자 생성
    * 데이터의 의미와는 무관한 숫자나 랜덤한 문자의 나열등으로도 생성 가능


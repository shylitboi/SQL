# SQL_ADVANCED 1주차 정규 과제 

## Week 1 : 서브쿼리 & CTE

📌**SQL_ADVANCED 정규과제**는 매주 정해진 주제에 따라 **MySQL 공식 문서 또는 한글 블로그 자료를 참고해 개념을 정리한 후, 프로그래머스 SQL 3문제**와 **추가 확인문제**를 직접 풀어보며 학습하는 과제입니다. 

이번 주는 아래의 **SQL_ADVANCED_0th_TIL**에 나열된 주제를 중심으로 개념을 학습하고, 주차별 **학습 목표**에 맞게 정리해주세요. 정리한 내용은 GitHub에 업로드한 후, **스프레드시트의 'SQL' 시트에 링크를 제출**해주세요. 



**👀 (수행 인증샷은 필수입니다.)** 

> 프로그래머스 문제를 풀고 '정답입니다' 문구를 캡쳐해서 올려주시면 됩니다. 



## SQL_ADVANCED_1st_TIL 

### 15.2.15. SubQueries

#### 특히 15.2.15.1 ~ 15.2.15.7 (Scalar, EXISTS, Correlated, Derived 등) 

### 15.2.20 WITH (Common Table Expressions)

- `WITH RECURSIVE`에 대한 내용은 추후에 공부합니다. 해당 링크에서 `WITH`에 해당하는 부분만 정리해보세요. 




## 🏁 주차별 학습 (Study Schedule)

| 주차  | 공부 범위               | 완료 여부 |
| ----- | ----------------------- | --------- |
| 1주차 | 서브쿼리 & CTE          | ✅         |
| 2주차 | 집합 연산자 & 그룹 함수 | 🍽️         |
| 3주차 | 윈도우 함수             | 🍽️         |
| 4주차 | Top N 쿼리              | 🍽️         |
| 5주차 | 계층형 질의와 셀프 조인 | 🍽️         |
| 6주차 | PIVOT / UNPIVOT         | 🍽️         |
| 7주차 | 정규 표현식             | 🍽️         |

<br>


### 공식 문서 활용 팁

>  **MySQL 공식 문서는 영어로 제공되지만, 크롬 브라우저에서 공식 문서를 열고 이 페이지 번역하기에서 한국어를 선택하면 번역된 버전으로 확인할 수 있습니다. 다만, 번역본은 문맥이 어색한 부분이 종종 있으니 영어 원문과 한국어 번역본을 왔다 갔다 하며 확인하거나, 교육팀장의 정리 예시를 참고하셔도 괜찮습니다.**



# 1️⃣ 학습 내용 

> 아래의 링크를 통해 *MySQL 공식문서*로 이동하실 수 있습니다.
>
> - SubQueries : MySQL 공식문서 
>
> https://dev.mysql.com/doc/refman/8.0/en/subqueries.html
>
> (한국어 버전)
> https://dart-b-official.github.io/posts/mysql-subqueries/


> - CTE(공통 테이블 표현식) : MySQL 공식문서
>
> https://dev.mysql.com/doc/refman/8.0/en/with.html
>
> (한국어 버전)
> https://dart-b-official.github.io/posts/mysql-cte/

<br>
<br>
<!-- 여기까진 그대로 둬 주세요-->





# 2️⃣ 학습 내용 정리하기

---

 # 1. 서브쿼리

~~~
✅ 학습 목표 :
* SubQueries에 대한 문법을 이해하고 활용할 수 있다.  
~~~

<!-- 새롭게 배운 내용을 자유롭게 정리해주세요.-->

>## 1. 서브쿼리

* 개념 : 하나의 쿼리 안에 또 다른 쿼리. 바깥 쿼리는 메인쿼리.
    * 메인쿼리의 컬럼이 포함된 서브쿼리는 연관 서브쿼리, 포함되지 않은 서브쿼리는 비연관 서브쿼리라고 함
* 위치 
    * select 절 : 스칼라 서브쿼리
    * from : 인라인 뷰
    * where, having : 중첩 서브쿼리
    * ORDER BY, INSERT의 VALUES, 심지어 UPDATE의 SET, DELETE에도 사용 가능



> 예시
#### 1. SELECT 절 → **스칼라 서브쿼리 (Scalar Subquery)**

* **특징**: SELECT 절에서 컬럼처럼 사용되는 서브쿼리
* 반드시 \*\*단일 값(스칼라 값, 한 행 한 컬럼)\*\*을 반환해야 함
* 여러 행/컬럼을 반환하면 오류 발생

```sql
SELECT emp_name,
       (SELECT dept_name 
          FROM dept d 
         WHERE d.dept_id = e.dept_id) AS dept_name
FROM emp e;
```

👉 `dept_name`을 직접 조인하지 않고, SELECT 절에서 **하나의 값만 뽑아내는 쿼리**라서 "스칼라"라고 부름

---

#### 2. FROM 절 → **인라인 뷰 (Inline View)**

* **특징**: FROM 절에 서브쿼리가 들어와서 **마치 임시 테이블처럼 동작**
* 메인 쿼리에서 이 서브쿼리를 하나의 "뷰"처럼 참조할 수 있음

```sql
SELECT dept_id, avg_salary
FROM (
        SELECT dept_id, AVG(salary) AS avg_salary
        FROM emp
        GROUP BY dept_id
     ) tmp
WHERE avg_salary > 5000;
```

👉 `tmp`라는 **임시 테이블**을 만드는 것과 동일 → 그래서 "인라인 뷰"라고 부름

---

#### 3. WHERE / HAVING 절 → **중첩 서브쿼리 (Nested Subquery)**

* **특징**: 조건식 안에 들어가서, 메인쿼리의 행과 비교됨
* 보통 `IN`, `EXISTS`, `=`, `ANY`, `ALL` 등과 함께 쓰임

```sql
-- WHERE 절 예시
SELECT emp_name
FROM emp
WHERE dept_id IN (SELECT dept_id FROM dept WHERE location = 'SEOUL');

-- HAVING 절 예시
SELECT dept_id, AVG(salary)
FROM emp
GROUP BY dept_id
HAVING AVG(salary) > (SELECT AVG(salary) FROM emp);
```

👉 메인쿼리의 **조건을 결정하는 역할**이라 "중첩" 서브쿼리라고 부름

---

#### 🔑 정리

| 위치               | 이름       | 특징               |
| ---------------- | -------- | ---------------- |
| **SELECT**       | 스칼라 서브쿼리 | 단일 값 반환, 컬럼처럼 사용 |
| **FROM**         | 인라인 뷰    | 임시 테이블(뷰)처럼 동작   |
| **WHERE/HAVING** | 중첩 서브쿼리  | 조건식을 결정하는 데 사용   |

### 스칼라 서브쿼리
: 주로 select절에 위치, 컬럼이 올 수 있는 대부분 위치에 사용 가능
* 컬럼 대신 사용되므로 반드시 **하나의 값만을 반환해야함, 아니면 에러**
* 여러 값 반환할려면 서브쿼리 여러개 해야지

### 인라인 뷰
: from 절 등 테이블 명이 올 수 있는 위치에 사용 가능
### 중첩 서브 쿼리

A) WHERE, HAVING절에 사용 가능. 중첩 서브쿼리는 메인 쿼리와 관계에 따라 아래와 같이 구분
1) 연관 서브쿼리 : 메인쿼리의 컬럼 포함됨, 단독 실행 불가
    ```sql
    SELECT emp_name, salary
    FROM emp e
    WHERE salary > (
        SELECT AVG(salary)
        FROM emp
        WHERE dept_id = e.dept_id);
    ```
2) 비연관 서브쿼리  : 메인쿼리의 컬럼이 없음, 단독 실행 가능
    ```sql
    SELECT emp_name, salary
    FROM emp
    WHERE salary > (SELECT AVG(salary) FROM emp);
    ```
B) 반환하는 형태에 따라 3가지로 구분

1) 단일 행 서브쿼리 : 항상 1건 이하의 결과만 반환
    * 단일 행 비교 연산자(=, <, > 등)과 함께 사용
    ```sql
    select ~~~
    from~
    where price = (Select max(price) from product)
    ```
2) 다중 행 서브쿼리 : 2건 이상의 행 반환
    * 다중 행 비교 연산자와 함게 사용(```IN, ALL, ANY, SOME, EXISTS```)
3) 다중 컬럼 서브 쿼리
    * 서브쿼리가 여러 개의 컬럼을 반환하는 경우

    * 메인쿼리에서 복수 컬럼을 동시에 비교할 때 사용

    * 일반적인 단일 컬럼 서브쿼리보다 조건이 더 정교해짐**(하지만 단일행+다중컬럼일 경우 단일행 비교 연산자 사용 가능)**
    ```sql
    SELECT emp_id, emp_name, dept_id, salary
    FROM emp
    WHERE (dept_id, salary) IN (
            SELECT dept_id, MIN(salary)
            FROM emp
            GROUP BY dept_id
        );
    ```

    * 특징
        * (컬럼1, 컬럼2, …) 형태로 묶어서 비교

        * 반드시 서브쿼리에서 반환하는 컬럼 수와 메인쿼리에서 비교하는 컬럼 수가 같아야 함

        | 서브쿼리 유형    | 결과 형태  | 사용 연산자               |
        | ---------- | ------ | -------------------- |
        | 단일 행 서브쿼리  | 1행 1컬럼 | =, <, >, <=, >=, <>  |
        | 다중 행 서브쿼리  | N행 1컬럼 | IN, ANY, ALL, EXISTS |
        | 단일 행 다중 컬럼 | 1행 N컬럼 | = (튜플 비교)            |
        | 다중 행 다중 컬럼 | N행 N컬럼 | IN, EXISTS (튜플 비교)   |



---

# 📌 1. IN

* 서브쿼리 결과 집합 중 **하나라도 일치**하면 참
* 여러 개 값 비교할 때 많이 씀

```sql
SELECT emp_name
FROM emp
WHERE dept_id IN (SELECT dept_id FROM dept WHERE location_id = 1700);
```

👉 `dept_id`가 서브쿼리 결과에 속하면 조회

---

# 📌 2. ANY (또는 SOME)

* 서브쿼리의 여러 결과 중 **하나라도 만족**하면 참
* 보통 비교 연산자와 같이 사용

```sql
SELECT emp_name, salary
FROM emp
WHERE salary > ANY (SELECT salary FROM emp WHERE dept_id = 10);
```

👉 부서 10의 직원 중 **최소 한 명의 급여보다 크면** 조회됨
\= **최소값 기준 비교**

---

# 📌 3. ALL

* 서브쿼리의 모든 결과와 비교해서 **모두 만족**해야 참

```sql
SELECT emp_name, salary
FROM emp
WHERE salary > ALL (SELECT salary FROM emp WHERE dept_id = 10);
```

👉 부서 10의 직원 급여 **전부보다 커야** 조회됨
\= **최댓값 기준 비교**

---

# 📌 4. EXISTS

* 서브쿼리 결과가 **하나라도 존재하면 참**
* 보통 `EXISTS (SELECT 1 ...)` 형태로 많이 씀 (반환값은 중요하지 않음, "존재 여부"만 체크)

```sql
SELECT emp_name
FROM emp e
WHERE EXISTS (SELECT 1
                FROM bonus b
               WHERE b.emp_id = e.emp_id);
```

👉 `emp_id`가 `bonus` 테이블에 존재하는 직원만 조회

---

# 📌 요약 비교

| 연산자       | 의미             | 사용 예시               | 특징            |
| --------- | -------------- | ------------------- | ------------- |
| IN        | 집합 안에 포함되면 참   | `x IN (1,2,3)`      | 단순 포함 여부      |
| ANY(SOME) | 여러 값 중 하나라도 만족 | `x > ANY (서브쿼리)`    | 최소 기준         |
| ALL       | 여러 값 전부 만족     | `x > ALL (서브쿼리)`    | 최대 기준         |
| EXISTS    | 서브쿼리 결과 존재 여부  | `EXISTS (SELECT …)` | 조건 충족 행 존재 여부 |

---

✅ 한 줄 정리:

* **IN** → "값이 집합 안에 있니?"
* **ANY** → "값이 최소 하나랑 비교해도 되니?"
* **ALL** → "모든 값과 비교해도 되니?"
* **EXISTS** → "해당 조건을 만족하는 행이 있니?"

# 2. CTE

~~~
✅ 학습 목표 :
* CTE에 대한 문법을 이해하고 활용할 수 있다. 
~~~

<!-- 새롭게 배운 내용을 자유롭게 정리해주세요.-->


>## CTE : 공통 테이블 표현식
* 개념 :CTE(Common Table Expression)는 하위 쿼리(subquery)의 결과 집합에 이름을 붙여 재사용할 수 있는 구문이다.

    * WITH 절을 이용해 정의하며, 이후 SELECT, UPDATE, DELETE 등에서 마치 테이블처럼 참조 가능하다.

종류
* 일반 CTE
* 재귀 CTE
* 재귀 깊이 제한
* 재귀 CTE 예제
* CTE와 유사한 구조 비교

>### 기본 CTE
```sql
WITH
  cte1 AS (SELECT a, b FROM table1),
  cte2 AS (SELECT c, d FROM table2)
SELECT b, d FROM cte1 JOIN cte2
WHERE cte1.a = cte2.c;
```


>### 주요 특징

* cte1, cte2는 각각의 하위 쿼리 결과 집합을 이름으로 정의한다.

* CTE 내부에서는 앞서 정의된 다른 CTE 참조 가능
(⚠️ 단, 뒤에 정의된 CTE는 참조 불가).

* 이름 해석 순서
서브쿼리 > CTE > 기본 테이블/뷰

>### 구문 규칙

* WITH 절은 SELECT, UPDATE, DELETE 앞에 위치할 수 있음.

* 또한 INSERT, REPLACE, CREATE TABLE/VIEW, DECLARE CURSOR, EXPLAIN 문에서도 사용 가능.

* 하나의 SQL 문장 레벨에는 WITH 절 단 하나만 허용.

* 여러 CTE는 , 로 구분하여 나열.

* CTE 이름은 반드시 유일(unique) 해야 함.

>### 컬럼 이름 규칙

* CTE 정의 시 (col1, col2, …) 형태로 지정 → 해당 컬럼명 사용.

* 지정하지 않으면 → 첫 번째 SELECT 문의 select list에서 컬럼명 자동 사용.

```sql
WITH cte(col1, col2) AS (
    SELECT a, b FROM my_table
)
SELECT col1, col2 FROM cte;
```

>### CTE vs 파생 테이블(Derived Table)
✅ 공통점

이름이 있다.

단일 SQL 문장에서만 존재한다.

🔀 차이점

| 구분    | CTE                   | 파생 테이블     |
| ----- | --------------------- | ---------- |
| 참조 횟수 | 여러 번 참조 가능            | 한 번만 참조 가능 |
| 자기 참조 | 가능 (재귀)               | 불가능        |
| 가독성   | 뛰어남                   | 복잡해질 수 있음  |
| 임시성   | 테이블 생성 불필요, 가볍게 사용 가능 | 중첩 구조로만 사용 |

<br>

<br>

---

# 3️⃣ 실습 문제

**두 문제 중에서 한 문제는 SubQuery와 CTE를 사용한 방법을 각각 활용해서 2개의 답변을 제시해주세요**

## 프로그래머스 문제 

https://school.programmers.co.kr/learn/courses/30/lessons/131123

> 즐겨찾기가 가장 많은 식당 정보 출력하기 (GROUP BY, SubQuery) : Lev 3

https://school.programmers.co.kr/learn/courses/30/lessons/131115

> 가격이 제일 비싼 식품의 정보 출력하기 (SUM, MAX, MIN, SubQuery) : Lev 2



---

## 문제 인증란





---


## 문제 1

> **🧚예린이는 최근 여러 주문 데이터를 분석하는 업무를 맡게 되었습니다. 특정 고객의 주문 이력을 분석하기 위해, 다음과 같이 최근 30일간 주문만 필터링한 CTE를 사용해 쿼리를 작성했습니다.**

~~~sql
WITH RecentOrders AS (
  SELECT *
  FROM Orders
  WHERE order_date >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)
)
SELECT customer_id, COUNT(*) AS recent_order_count
FROM RecentOrders
GROUP BY customer_id;
~~~

> **그런데 예린이는 "이 쿼리를 WITH 없이, 서브쿼리 방식으로 바꿔서 실행해보라" 는 피드백을 받았고, 서브쿼리로 작성해보려 했지만 익숙하지 않아 SQL_ADVANCED를 듣는 학회원분들에게 도움을 요청하고 있습니다. 예린이의 쿼리를 WITH 없이 서브쿼리로 변환해보세요. 그리고 두 방식의 차이점을 설명해보고, 각각의 장단점을 정리해보세요**




```sql
SELECT customer_id, COUNT(*) AS recent_order_count
FROM (
  SELECT *
  FROM Orders
  WHERE order_date >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)
) AS RecentOrders
GROUP BY customer_id;

```


## 참고자료

서브쿼리를 사용하는 이유가 너무 어려우신 분들을 위해 참고자료를 첨부합니다. 아래 블로그를 통해서 더욱 쉽게 공부해보시고 문제를 풀어보세요.

1. [SQL] 서브쿼리는 언제 쓰는걸까? 
   https://project-notwork.tistory.com/38

2. [SQLD] 서브 쿼리 (SubQeury) 개념 및 종류
   https://bommbom.tistory.com/entry/%EC%84%9C%EB%B8%8C-%EC%BF%BC%EB%A6%ACSub-Query-%EA%B0%9C%EB%85%90-%EB%B0%8F-%EC%A2%85%EB%A5%98


### 🎉 수고하셨습니다.